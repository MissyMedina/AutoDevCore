"""
README Writer Agent - Generates comprehensive README files
"""

from typing import Dict, Any


class READMEWriterAgent:
    """Agent responsible for generating comprehensive README files."""
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
    
    def generate_readme(self, app_plan: Dict[str, Any], app_name: str) -> str:
        """
        Generate a comprehensive README file.
        
        Args:
            app_plan: The app plan from the composer agent
            app_name: The name of the application
            
        Returns:
            Markdown-formatted README content
        """
        if self.verbose:
            print(f"[READMEWriterAgent] Generating README for: {app_name}")
        
        idea = app_plan.get('description', 'AutoDevCore Generated App')
        tech_stack = app_plan.get('tech_stack', {})
        
        readme_content = f"""# {app_name}

{idea}

*Generated by AutoDevCore - The core of intelligent development.*

## üöÄ Features

{self._format_features(app_plan.get('features', []))}

## üìã Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
- [API Documentation](#api-documentation)
- [Architecture](#architecture)
- [Development](#development)
- [Testing](#testing)
- [Deployment](#deployment)
- [Contributing](#contributing)
- [License](#license)

## ‚öôÔ∏è Installation

### Prerequisites

- Python 3.11+ (for Python backend)
- Node.js 18+ (for Node.js backend)
- Git

### Quick Start

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd {app_name.lower().replace(' ', '-')}
   ```

2. **Install dependencies**
   ```bash
   # For Python backend
   pip install -r requirements.txt
   
   # For Node.js backend
   npm install
   ```

3. **Set up environment variables**
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

4. **Run the application**
   ```bash
   # Python backend
   python main.py
   
   # Node.js backend
   npm start
   ```

The application will be available at `http://localhost:8000` (Python) or `http://localhost:3000` (Node.js).

## üõ†Ô∏è Usage

### API Endpoints

{self._format_api_endpoints(app_plan.get('api_endpoints', []))}

### Example Requests

```bash
# Health check
curl http://localhost:8000/health

# Get all users
```

## üìö API Documentation

When running the application, you can access the interactive API documentation:

- **Swagger UI**: `http://localhost:8000/docs` (Python/FastAPI)
- **ReDoc**: `http://localhost:8000/redoc` (Python/FastAPI)

## üèóÔ∏è Architecture

### Tech Stack

{self._format_tech_stack(tech_stack)}

### System Design

{self._format_architecture(app_plan.get('architecture', {}))}

### Database Schema

{self._format_database_schema(app_plan.get('database_schema', {}))}

## üß™ Development

### Project Structure

```
{app_name.lower().replace(' ', '-')}/
‚îú‚îÄ‚îÄ main.py                 # Application entry point
‚îú‚îÄ‚îÄ models.py              # Database models
‚îú‚îÄ‚îÄ database.py            # Database configuration
‚îú‚îÄ‚îÄ config.py              # Application settings
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ routes.py          # API routes
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ helpers.py         # Utility functions
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ test_main.py       # Test files
‚îú‚îÄ‚îÄ requirements.txt        # Python dependencies
‚îú‚îÄ‚îÄ .env.example           # Environment variables template
‚îú‚îÄ‚îÄ Dockerfile             # Docker configuration
‚îî‚îÄ‚îÄ README.md              # This file
```

### Development Setup

1. **Create a virtual environment** (Python)
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\\Scripts\\activate
   ```

2. **Install development dependencies**
   ```bash
   pip install -r requirements.txt
   pip install pytest pytest-cov black flake8
   ```

3. **Run in development mode**
   ```bash
   # Python with auto-reload
   uvicorn main:app --reload --host 0.0.0.0 --port 8000
   
   # Node.js with auto-reload
   npm run dev
   ```

## üß™ Testing

### Running Tests

```bash
# Python tests
pytest tests/ -v

# Node.js tests
npm test
```

### Test Coverage

```bash
# Python coverage
pytest --cov=. tests/

# Generate coverage report
coverage html
```

### API Testing

You can test the API endpoints using the provided test files or tools like:

- **Postman**: Import the API collection
- **curl**: Use the example commands above
- **Swagger UI**: Interactive testing at `/docs`

## üöÄ Deployment

### Docker Deployment

1. **Build the Docker image**
   ```bash
   docker build -t {app_name.lower().replace(' ', '-')} .
   ```

2. **Run the container**
   ```bash
   docker run -p 8000:8000 {app_name.lower().replace(' ', '-')}
   ```

### Production Deployment

#### Environment Variables

Set the following environment variables for production:

```bash
# Database
DATABASE_URL=postgresql://user:password@localhost/dbname

# Security
SECRET_KEY=your-production-secret-key

# Application
DEBUG=False
APP_NAME={app_name}

# API
API_HOST=0.0.0.0
API_PORT=8000
```

#### Deployment Options

- **Docker**: Use the provided Dockerfile
- **Heroku**: Deploy directly from Git
- **AWS**: Use Elastic Beanstalk or ECS
- **Google Cloud**: Use App Engine or Cloud Run

## üîß Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `DATABASE_URL` | Database connection string | `sqlite:///./app.db` |
| `SECRET_KEY` | Application secret key | `your-secret-key-here` |
| `DEBUG` | Debug mode | `False` |
| `APP_NAME` | Application name | `{app_name}` |
| `API_HOST` | API host address | `0.0.0.0` |
| `API_PORT` | API port | `8000` |

### Database Configuration

The application supports multiple database backends:

- **SQLite**: Default for development
- **PostgreSQL**: Recommended for production
- **MySQL**: Supported via SQLAlchemy

## ü§ù Contributing

1. **Fork the repository**
2. **Create a feature branch**
   ```bash
   git checkout -b feature/amazing-feature
   ```
3. **Make your changes**
4. **Run tests**
   ```bash
   pytest tests/ -v
   ```
5. **Commit your changes**
   ```bash
   git commit -m 'Add amazing feature'
   ```
6. **Push to the branch**
   ```bash
   git push origin feature/amazing-feature
   ```
7. **Open a Pull Request**

### Code Style

- **Python**: Follow PEP 8, use Black for formatting
- **JavaScript**: Follow ESLint rules, use Prettier for formatting

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- Generated by [AutoDevCore](https://github.com/yourorg/AutoDevCore)
- Built with modern web technologies
- Designed for scalability and maintainability

---

*This README was generated by AutoDevCore - The core of intelligent development.*
"""
        
        return readme_content
    
    def _format_features(self, features: list) -> str:
        """Format features as a markdown list."""
        if not features:
            return "- Basic CRUD operations\n- User authentication\n- RESTful API\n- Database integration"
        
        formatted_features = []
        for feature in features:
            formatted_features.append(f"- {feature}")
        
        return "\n".join(formatted_features)
    
    def _format_api_endpoints(self, endpoints: list) -> str:
        """Format API endpoints information."""
        if not endpoints:
            return "Standard REST API endpoints"
        
        endpoint_text = []
        for endpoint in endpoints:
            if isinstance(endpoint, dict):
                method = endpoint.get('method', 'GET')
                path = endpoint.get('path', '/')
                description = endpoint.get('description', 'API endpoint')
                endpoint_text.append(f"- **{method} {path}**: {description}")
            else:
                # Handle string format
                endpoint_text.append(f"- **{endpoint}**")
        
        return "\n".join(endpoint_text)
    
    def _format_tech_stack(self, tech_stack: Dict[str, str]) -> str:
        """Format tech stack information."""
        if not tech_stack:
            return "Standard web application stack with modern frameworks."
        
        stack_content = "| Component | Technology |\n"
        stack_content += "|-----------|------------|\n"
        
        for component, technology in tech_stack.items():
            stack_content += f"| {component.title()} | {technology} |\n"
        
        return stack_content
    
    def _format_architecture(self, architecture: Dict[str, Any]) -> str:
        """Format architecture information."""
        pattern = architecture.get('pattern', 'MVC')
        layers = architecture.get('layers', [])
        
        layers_text = "\n".join([f"- {layer}" for layer in layers])
        
        return f"""
**Architecture Pattern**: {pattern}

**System Layers**:
{layers_text}

The application follows a layered architecture pattern for maintainability and scalability.
"""
    
    def _format_database_schema(self, schema: Dict[str, Any]) -> str:
        """Format database schema information."""
        tables = schema.get('tables', [])
        
        if not tables:
            return "Standard database schema with user and data tables."
        
        schema_text = "### Database Tables\n\n"
        
        for table in tables:
            table_name = table.get('name', 'unknown')
            columns = table.get('columns', [])
            
            schema_text += f"#### {table_name}\n\n"
            schema_text += "| Column | Type | Constraints |\n"
            schema_text += "|--------|------|-------------|\n"
            
            for column in columns:
                col_name = column.get('name', 'unknown')
                col_type = column.get('type', 'TEXT')
                constraints = []
                
                if column.get('primary_key'):
                    constraints.append('PRIMARY KEY')
                if column.get('unique'):
                    constraints.append('UNIQUE')
                if column.get('nullable') is False:
                    constraints.append('NOT NULL')
                
                constraint_text = ', '.join(constraints) if constraints else '-'
                schema_text += f"| {col_name} | {col_type} | {constraint_text} |\n"
            
            schema_text += "\n"
        
        return schema_text
